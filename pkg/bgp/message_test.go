package bgp

import (
	"net"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

var optByte = []byte{0x02, 0x06, 0x01, 0x04, 0x00, 0x01, 0x00, 0x01, // multi protocol extensions
	0x02, 0x02, 0x80, 0x00, // route refresh cisco
	0x02, 0x02, 0x02, 0x00, // route refresh
	0x02, 0x06, 0x41, 0x04, 0x00, 0x00, 0x00, 0x64, // 4-octet AS number
	0x02, 0x06, 0x45, 0x04, 0x00, 0x01, 0x01, 0x01, // additional path
	0x02, 0x1b, 0x49, 0x19, 0x0c, 0x33, 0x64, 0x30, 0x66, 0x66, 0x63, 0x36, 0x61, 0x38, 0x38, 0x61, 0x38, 0x0b, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, // fqdn
	0x02, 0x04, 0x40, 0x02, 0x00, 0x78, // graceful restart
}

func TestParse(t *testing.T) {
	for _, d := range []struct {
		data   []byte
		packet *Packet
	}{
		// https://www.cloudshark.org/captures/db5af52c1c80
		{
			data: []byte{
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x2d, 0x01, 0x04, 0x00, 0x1e, 0x00, 0xb4, 0x0a, 0x00,
				0x00, 0x09, 0x10, 0x02, 0x06, 0x01, 0x04, 0x00, 0x01, 0x00, 0x01, 0x02, 0x02, 0x80, 0x00, 0x02,
				0x02, 0x02, 0x00,
			},
			packet: &Packet{
				Header: &Header{
					Maker:  [16]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
					Length: 45,
					Type:   OPEN,
				},
			},
		},
		// https://www.cloudshark.org/captures/db5af52c1c80
		{
			data: []byte{
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x13, 0x04,
			},
			packet: &Packet{
				Header: &Header{
					Maker:  [16]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
					Length: 19,
					Type:   KEEPALIVE,
				},
			},
		},
		// https://www.cloudshark.org/captures/db5af52c1c80
		{
			data: []byte{
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x43, 0x02, 0x00, 0x00, 0x00, 0x28, 0x40, 0x01, 0x01,
				0x02, 0x40, 0x02, 0x0a, 0x02, 0x01, 0x00, 0x1e, 0x01, 0x02, 0x00, 0x0a, 0x00, 0x14, 0x40, 0x03,
				0x04, 0x0a, 0x00, 0x00, 0x09, 0x80, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x07, 0x06, 0x00,
				0x1e, 0x0a, 0x00, 0x00, 0x09, 0x15, 0xac, 0x10, 0x00,
			},
			packet: &Packet{
				Header: &Header{
					Maker:  [16]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
					Length: 67,
					Type:   UPDATE,
				},
			},
		},
		// https://www.cloudshark.org/captures/ca1b663c5757
		{
			data: []byte{
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x17, 0x03, 0x02, 0x02, 0xfe, 0xb0,
			},
			packet: &Packet{
				Header: &Header{
					Maker:  [16]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
					Length: 23,
					Type:   NOTIFICATION,
				},
			},
		},
	} {
		p, err := Parse(d.data)
		require.NoError(t, err)
		assert.Equal(t, d.packet.Header, p.Header)
		assert.Equal(t, d.packet.Header.Type, p.Message.Type())
	}
}

func TestPacketDecode(t *testing.T) {
	for _, d := range [][]byte{
		{
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x2d, 0x01, 0x04, 0x00, 0x1e, 0x00, 0xb4, 0x0a, 0x00,
			0x00, 0x09, 0x10, 0x02, 0x06, 0x01, 0x04, 0x00, 0x01, 0x00, 0x01, 0x02, 0x02, 0x80, 0x00, 0x02,
			0x02, 0x02, 0x00},
		{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x13, 0x04},
		{
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x43, 0x02, 0x00, 0x00, 0x00, 0x28, 0x40, 0x01, 0x01,
			0x02, 0x40, 0x02, 0x0a, 0x02, 0x01, 0x00, 0x1e, 0x01, 0x02, 0x00, 0x0a, 0x00, 0x14, 0x40, 0x03,
			0x04, 0x0a, 0x00, 0x00, 0x09, 0x80, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x07, 0x06, 0x00,
			0x1e, 0x0a, 0x00, 0x00, 0x09, 0x15, 0xac, 0x10, 0x00},
		{
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x17, 0x03, 0x02, 0x02, 0xfe, 0xb0},
	} {
		p, err := Parse(d)
		require.NoError(t, err)
		data, err := p.Decode()
		require.NoError(t, err)
		assert.Equal(t, d, data)
	}
}

func TestParseOpenMsg(t *testing.T) {
	for _, d := range []struct {
		data []byte
		exp  *Open
	}{
		{
			data: []byte{0x04, 0xfe, 0xb0, 0x00, 0xb4, 0x0a, 0x14, 0x03, 0x01, 0x10, 0x02, 0x06, 0x01, 0x04, 0x00, 0x01, 0x00, 0x01, 0x02, 0x02, 0x80, 0x00, 0x02, 0x02, 0x02, 0x00},
			exp: &Open{
				Version:    4,
				AS:         65200,
				HoldTime:   180,
				Identifier: net.ParseIP("10.20.3.1").To4(),
				OptParmLen: 16,
				Options: []*Option{
					{Type: ParameterType(2), Length: 6, Value: []byte{0x01, 0x04, 0x00, 0x01, 0x00, 0x01}},
					{Type: ParameterType(2), Length: 2, Value: []byte{0x80, 0x00}},
					{Type: ParameterType(2), Length: 2, Value: []byte{0x02, 0x00}},
				},
			},
		},
		{
			data: []byte{0x04, 0x00, 0x1e, 0x00, 0xb4, 0x0a, 0x00, 0x00, 0x09, 0x10, 0x02, 0x06, 0x01, 0x04, 0x00, 0x01, 0x00, 0x01, 0x02, 0x02, 0x80, 0x00, 0x02, 0x02, 0x02, 0x00},
			exp: &Open{
				Version:    4,
				AS:         30,
				HoldTime:   180,
				Identifier: net.ParseIP("10.0.0.9").To4(),
				OptParmLen: 16,
				Options: []*Option{
					{Type: ParameterType(2), Length: 6, Value: []byte{0x01, 0x04, 0x00, 0x01, 0x00, 0x01}},
					{Type: ParameterType(2), Length: 2, Value: []byte{0x80, 0x00}},
					{Type: ParameterType(2), Length: 2, Value: []byte{0x02, 0x00}},
				},
			},
		},
	} {
		op, err := ParseOpenMsg(d.data)
		require.NoError(t, err)
		assert.Equal(t, d.exp.Version, op.Version)
		assert.Equal(t, d.exp.AS, op.AS)
		assert.Equal(t, d.exp.HoldTime, op.HoldTime)
		assert.Equal(t, d.exp.Identifier, op.Identifier)
		assert.Equal(t, d.exp.OptParmLen, op.OptParmLen)
		assert.Equal(t, d.exp.Options, op.Options)
	}
}

func TestParseUpdateMsg(t *testing.T) {
	for _, d := range []struct {
		data []byte
		exp  *Update
	}{
		// https://www.cloudshark.org/captures/db5af52c1c80
		{
			data: []byte{0x00, 0x00, 0x00, 0x28, 0x40, 0x01, 0x01,
				0x02, 0x40, 0x02, 0x0a, 0x02, 0x01, 0x00, 0x1e, 0x01, 0x02, 0x00, 0x0a, 0x00, 0x14, 0x40, 0x03,
				0x04, 0x0a, 0x00, 0x00, 0x09, 0x80, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x07, 0x06, 0x00,
				0x1e, 0x0a, 0x00, 0x00, 0x09, 0x15, 0xac, 0x10, 0x00},
			exp: &Update{
				WithdrawnRoutesLen: 0,
				WithdrawnRoutes:    []*Prefix{},
				TotalPathAttrLen:   40,
				PathAttrs: []*PathAttr{
					{Flags: PATH_ATTR_FLAG_TRANSITIVE, Type: ORIGIN, Value: []byte{0x02}},
					{Flags: PATH_ATTR_FLAG_TRANSITIVE, Type: AS_PATH, Value: []byte{0x02, 0x01, 0x00, 0x1e, 0x01, 0x02, 0x00, 0x0a, 0x00, 0x14}},
					{Flags: PATH_ATTR_FLAG_TRANSITIVE, Type: NEXT_HOP, Value: []byte{0x0a, 0x00, 0x00, 0x09}},
					{Flags: PATH_ATTR_FLAG_OPTIONAL, Type: MULTI_EXIT_DISC, Value: []byte{0x00, 0x00, 0x00, 0x00}},
					{Flags: PATH_ATTR_FLAG_OPTIONAL | PATH_ATTR_FLAG_TRANSITIVE, Type: AGGREGATOR, Value: []byte{0x00, 0x1e, 0x0a, 0x00, 0x00, 0x09}},
				},
				NetworkLayerReachabilityInfo: []*Prefix{{Length: 21, Prefix: net.ParseIP("172.16.0.0").To4()}},
			},
		},
		// https://www.cloudshark.org/captures/b837a07e9df5
		{
			data: []byte{0x00, 0x00, 0x00, 0x19, 0x40, 0x01, 0x01,
				0x00, 0x40, 0x02, 0x04, 0x02, 0x01, 0xfe, 0x4c, 0x40, 0x03, 0x04, 0x01, 0x01, 0x01, 0x01, 0x80,
				0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x18, 0x0a, 0x0a, 0x03, 0x18, 0x0a, 0x0a, 0x02, 0x18, 0x0a, 0x0a, 0x01},
			exp: &Update{
				WithdrawnRoutesLen: 0,
				WithdrawnRoutes:    []*Prefix{},
				TotalPathAttrLen:   25,
				PathAttrs: []*PathAttr{
					{Flags: PATH_ATTR_FLAG_TRANSITIVE, Type: ORIGIN, Value: []byte{0x00}},
					{Flags: PATH_ATTR_FLAG_TRANSITIVE, Type: AS_PATH, Value: []byte{0x02, 0x01, 0xfe, 0x4c}},
					{Flags: PATH_ATTR_FLAG_TRANSITIVE, Type: NEXT_HOP, Value: []byte{0x01, 0x01, 0x01, 0x01}},
					{Flags: PATH_ATTR_FLAG_OPTIONAL, Type: MULTI_EXIT_DISC, Value: []byte{0x00, 0x00, 0x00, 0x00}},
				},
				NetworkLayerReachabilityInfo: []*Prefix{
					{Length: 24, Prefix: net.ParseIP("10.10.3.0").To4()},
					{Length: 24, Prefix: net.ParseIP("10.10.2.0").To4()},
					{Length: 24, Prefix: net.ParseIP("10.10.1.0").To4()},
				},
			},
		},
	} {
		upd, err := ParseUpdateMsg(d.data)
		require.NoError(t, err)
		assert.Equal(t, d.exp.WithdrawnRoutesLen, upd.WithdrawnRoutesLen)
		assert.Equal(t, d.exp.WithdrawnRoutes, upd.WithdrawnRoutes)
		assert.Equal(t, d.exp.WithdrawnRoutes, upd.WithdrawnRoutes)
		assert.Equal(t, d.exp.TotalPathAttrLen, upd.TotalPathAttrLen)
		assert.Equal(t, d.exp.PathAttrs, upd.PathAttrs)
		assert.Equal(t, d.exp.NetworkLayerReachabilityInfo, upd.NetworkLayerReachabilityInfo)
	}
}

func TestParseNotificationMsg(t *testing.T) {
	for _, d := range []struct {
		data []byte
		exp  *Notification
	}{
		// https://www.cloudshark.org/captures/ca1b663c5757
		{data: []byte{0x02, 0x02, 0xfe, 0xb0}, exp: &Notification{ErrorCode: &ErrorCode{Code: OPEN_MESSAGE_ERROR, Subcode: BAD_PEER_AS}, Data: []byte{0xfe, 0xb0}}},
	} {
		notif, err := ParseNotificationMsg(d.data)
		require.NoError(t, err)
		assert.Equal(t, d.exp.ErrorCode.Code, notif.ErrorCode.Code)
	}
}

func TestOpen_Decode(t *testing.T) {
	for _, d := range [][]byte{
		{0x04, 0xfe, 0xb0, 0x00, 0xb4, 0x0a, 0x14, 0x03, 0x01, 0x10, 0x02, 0x06, 0x01, 0x04, 0x00, 0x01, 0x00, 0x01, 0x02, 0x02, 0x80, 0x00, 0x02, 0x02, 0x02, 0x00},
		{0x04, 0x00, 0x1e, 0x00, 0xb4, 0x0a, 0x00, 0x00, 0x09, 0x10, 0x02, 0x06, 0x01, 0x04, 0x00, 0x01, 0x00, 0x01, 0x02, 0x02, 0x80, 0x00, 0x02, 0x02, 0x02, 0x00},
	} {
		msg, err := ParseOpenMsg(d)
		require.NoError(t, err)
		data, err := msg.Decode(len(d))
		require.NoError(t, err)
		assert.Equal(t, d, data)
	}
}

func TestUpdate_Decode(t *testing.T) {
	for _, d := range [][]byte{
		{0x00, 0x00, 0x00, 0x28, 0x40, 0x01, 0x01,
			0x02, 0x40, 0x02, 0x0a, 0x02, 0x01, 0x00, 0x1e, 0x01, 0x02, 0x00, 0x0a, 0x00, 0x14, 0x40, 0x03,
			0x04, 0x0a, 0x00, 0x00, 0x09, 0x80, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x07, 0x06, 0x00,
			0x1e, 0x0a, 0x00, 0x00, 0x09, 0x15, 0xac, 0x10, 0x00},
		{0x00, 0x00, 0x00, 0x19, 0x40, 0x01, 0x01,
			0x00, 0x40, 0x02, 0x04, 0x02, 0x01, 0xfe, 0x4c, 0x40, 0x03, 0x04, 0x01, 0x01, 0x01, 0x01, 0x80,
			0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x18, 0x0a, 0x0a, 0x03, 0x18, 0x0a, 0x0a, 0x02, 0x18, 0x0a, 0x0a, 0x01},
	} {
		msg, err := ParseUpdateMsg(d)
		require.NoError(t, err)
		data, err := msg.Decode(len(d))
		require.NoError(t, err)
		assert.Equal(t, d, data)
	}
}

func TestNotification_Decode(t *testing.T) {
	for _, d := range [][]byte{
		{0x02, 0x02, 0xfe, 0xb0},
	} {
		msg, err := ParseNotificationMsg(d)
		require.NoError(t, err)
		data, err := msg.Decode(len(d))
		require.NoError(t, err)
		assert.Equal(t, d, data)
	}
}

func TestParseASPathAttr(t *testing.T) {
	for _, d := range []struct {
		data []byte
		attr *ASPathAttr
	}{
		{data: []byte{0x02, 0x01, 0xfe, 0x4c}, attr: &ASPathAttr{SegType: 2, SegLength: 1, AS2: []uint16{65100}}},
		{data: []byte{0x02, 0x02, 0xfe, 0x4c, 0xff, 0x14}, attr: &ASPathAttr{SegType: 2, SegLength: 2, AS2: []uint16{65100, 65300}}},
	} {
		attr, err := ParseASPathAttr(d.data)
		require.NoError(t, err)
		assert.Equal(t, d.attr.SegType, attr.SegType)
		assert.Equal(t, d.attr.SegLength, attr.SegLength)
		assert.Equal(t, d.attr.AS2, attr.AS2)
	}
}
